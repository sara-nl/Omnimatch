//#define  pi 3.14159265359
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <fftw.h>
#include <rfftw.h>

/* Lowpass filter (reduced complex !) */
void lowpass(fftw_complex *vol_four, float R, float smooth, int Nx, int Ny, int Nz)
{
  int ikx, iky, ikz, irun, Nx_red, Ny_red, Nz_red;
  float dist, dist2, dist3, dist4;
  fftw_complex zero; 

  Nx_red = (int) Nx/2 +1;
  Ny_red = (int) Ny/2 +1;
  Nz_red = (int) Nz/2 +1;
  zero.re = 0.0;zero.im = 0.0;
  

  irun = 0;
  for (ikz = 0; ikz < Nz_red; ikz++)
    {
      for (iky = 0; iky < Ny_red; iky++)
	{
	  for (ikx = 0; ikx < Nx_red; ikx++)
	    {
	      /* 1st quadrant */
	      dist = ((float) (ikx*ikx+iky*iky+ikz*ikz)) ;
	      dist = sqrt(dist);
	      /* other quadrants */
	      dist2 = ((float) (ikx*ikx+(Ny-iky)*(Ny-iky)+ikz*ikz)) ;
	      dist2 = sqrt(dist2);
	      dist3 = ((float) (ikx*ikx+iky*iky+(Nz-ikz)*(Nz-ikz))) ;
	      dist3 = sqrt(dist3);
	      dist4 = ((float) (ikx*ikx+(Ny-iky)*(Ny-iky)+(Nz-ikz)*(Nz-ikz))) ;
	      dist4 = sqrt(dist4);
	      //if (dist > R)  vol_four[ikx + Nx_red*iky + ikz*Nx_red*Ny] =  zero ;
	      if ((dist2 > R) && (iky>0)) vol_four[ikx + Nx_red*(Ny-iky) + ikz*Nx_red*Ny] = zero;
	      //if ((dist3 > R) && (ikz>0)) vol_four[ikx + Nx_red*iky + (Nz-ikz)*Nx_red*Ny] = zero;
	      //if ((dist4 > R) && (iky>0) && (ikz>0)) vol_four[ikx + Nx_red*(Ny-iky) + (Nz-ikz)*Nx_red*Ny] = zero;
	    }
	}
    }
}
